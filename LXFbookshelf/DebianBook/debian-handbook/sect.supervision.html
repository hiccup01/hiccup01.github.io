<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.3. Supervision: Prevention, Detection, Deterrence</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 3.0" /><meta name="package" content="Debian-debian-handbook-6.0-en-US-1.0-1" /><meta name="keywords" content="Firewall, Netfilter, IDS/NIDS" /><link rel="home" href="index.html" title="The Debian Administrator's Handbook" /><link rel="up" href="security.html" title="Chapter 14. Security" /><link rel="prev" href="sect.firewall-packet-filtering.html" title="14.2. Firewall or Packet Filtering" /><link rel="next" href="sect.selinux.html" title="14.4. Introduction to SELinux" /></head><body><p class="hidden" id="title"><a class="left" href="http://www.debian.org"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://debian-handbook.info"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.firewall-packet-filtering.html"><strong>Prev</strong></a></li><li class="home">The Debian Administrator's Handbook</li><li class="next"><a accesskey="n" href="sect.selinux.html"><strong>Next</strong></a></li></ul><div class="section"><div class="titlepage"><div><div><h2 class="title" id="sect.supervision">14.3. Supervision: Prevention, Detection, Deterrence</h2></div></div></div><a id="idp12296408" class="indexterm"></a><a id="idp12296888" class="indexterm"></a><div class="para"><p></p>
			Monitoring is an integral part of any security policy for several reasons. Among them, that the goal of security is usually not restricted to guaranteeing data confidentiality, but it also includes ensuring availability of the services. It is therefore imperative to check that everything works as expected, and to detect in a timely manner any deviant behaviour or change in quality of the service(s) rendered. Monitoring activity can enable the detection of intrusion attempts and enable a swift reaction before they cause grave consequences. This section reviews some tools that can be used to monitor several aspects of a Debian system. As such, it completes the section dedicated to generic system monitoring in <a class="xref" href="advanced-administration.html">Chapter 12, <em>Advanced Administration</em></a>.
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.logcheck">14.3.1. Monitoring Logs with <code class="command">logcheck</code></h3></div></div></div><a id="idp12299296" class="indexterm"></a><a id="idp12299856" class="indexterm"></a><a id="idp12300576" class="indexterm"></a><div class="para"><p></p>
				The <code class="command">logcheck</code> program monitors log files every hour by default. It sends unusual log messages in emails to the administrator for further analysis.
			</div><div class="para"><p></p>
				The list of monitored files is stored in <code class="filename">/etc/logcheck/logcheck.logfiles</code>; the default values work fine if the <code class="filename">/etc/syslog.conf</code> file has not been completely overhauled.
			</div><div class="para"><p></p>
				<code class="command">logcheck</code> can work in one of three more or less detailed modes: <span class="emphasis"><em>paranoid</em></span>, <span class="emphasis"><em>server</em></span> and <span class="emphasis"><em>workstation</em></span>. The first one is <span class="emphasis"><em>very</em></span> verbose, and should probably be restricted to specific servers such as firewalls. The second (and default) mode is recommended for most servers. The last one is designed for workstations, and is even terser (it filters out more messages).
			</div><div class="para"><p></p>
				In all three cases, <code class="command">logcheck</code> should probably be customized to exclude some extra messages (depending on installed services), unless the admin really wishes to receive hourly batches of long uninteresting emails. Since the message selection mechanism is rather complex, <code class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> is a required — if challenging — read.
			</div><div class="para"><p></p>
				The applied rules can be split into several types:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para"><p></p>
						those that qualify a message as a cracking attempt (stored in a file in the <code class="filename">/etc/logcheck/cracking.d/</code> directory);
					</div></li><li class="listitem"><div class="para"><p></p>
						those cancelling such a qualification (<code class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li class="listitem"><div class="para"><p></p>
						those classifying a message as a security alert (<code class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li class="listitem"><div class="para"><p></p>
						those cancelling this classification (<code class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li class="listitem"><div class="para"><p></p>
						finally, those applying to the remaining messages (considered as <span class="emphasis"><em>system events</em></span>).
					</div></li></ul></div><div class="sidebar fil"><div class="titlepage"><div><div><h6><span class="emphasis"><em>CAUTION</em></span> Ignoring a message</h6></div></div></div><div class="para"><p></p>
				Any message tagged as a cracking attempt or a security alert (following a rule stored in a <code class="filename">/etc/logcheck/violations.d/myfile</code> file) can only be ignored by a rule in a <code class="filename">/etc/logcheck/violations.ignore.d/myfile</code> or <code class="filename">/etc/logcheck/violations.ignore.d/myfile-<em class="replaceable"><code>extension</code></em></code> file.
			</div></div><div class="para"><p></p>
				A system event is always signaled unless a rule in one of the <code class="filename">/etc/logcheck/ignore.d.{paranoid,server,workstation}/</code> directories states the event should be ignored. Of course, the only directories taken into account are those corresponding to verbosity levels equal or greater than the selected operation mode.
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>TIP</em></span> Your logs as screen background</h6></div></div></div><div class="para"><p></p>
				Some administrators like seeing their log messages scroll by in real time; the <code class="command">root-tail</code> command (in the <span class="pkg pkg">root-tail</span>) package can be used to integrate the logs into the background of their graphical desktop. The <code class="command">xconsole</code> program (in the <span class="emphasis"><em>x11-apps</em></span> package) can also have them scrolling in a small window. Messages are directly taken from <code class="command">syslogd</code> via the <code class="filename">/dev/xconsole</code> named pipe.
			</div><a id="idp12315128" class="indexterm"></a><a id="idp12315688" class="indexterm"></a></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.surveillance-activite">14.3.2. Monitoring Activity</h3></div></div></div><a id="idp12317248" class="indexterm"></a><a id="idp12317968" class="indexterm"></a><div class="section"><div class="titlepage"><div><div><h4 class="title" id="section.surveillance-temps-reel">14.3.2.1. In Real Time</h4></div></div></div><div class="para"><p></p>
					<code class="command">top</code> is an interactive tool that displays a list of currently running processes. The default sorting is based on the current amount of processor use and can be obtained with the <span class="keycap"><strong>P</strong></span> key. Other sort orders include a sort by occupied memory (<span class="keycap"><strong>M</strong></span> key), by total processor time (<span class="keycap"><strong>T</strong></span> key) and by process identifier (<span class="keycap"><strong>N</strong></span> key). The <span class="keycap"><strong>k</strong></span> key allows killing a process by entering its process identifier. The <span class="keycap"><strong>r</strong></span> key allows <span class="emphasis"><em>renicing</em></span> a process, i.e. changing its priority.
				</div><a id="idp12321544" class="indexterm"></a><div class="para"><p></p>
					When the system seems to be overloaded, <code class="command">top</code> is a great tool to see which processes are competing for processor time or consume too much memory. In particular, it is often interesting to check if the processes consuming resources match the real services that the machine is known to host. An unknown process running as the www-data user should really stand out and be investigated, since it's probably an instance of software installed and executed on the system through a vulnerability in a web application.
				</div><div class="para"><p></p>
					<code class="command">top</code> is a very flexible tool and its manual page gives details on how to customize its display and adapt it to one's personal needs and habits.
				</div><div class="para"><p></p>
					The <code class="command">gnome-system-monitor</code> and <code class="command">qps</code> graphical tools are similar to <code class="command">top</code> and they provide roughly the same features.
				</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>TIP</em></span> Visual representations of activity</h6></div></div></div><div class="para"><p></p>
					For more visual (and entertaining) representations of a computer's activity, one should investigate the <span class="pkg pkg">lavaps</span>, <span class="pkg pkg">bubblemon</span> and <span class="pkg pkg">bubblefishymon</span> packages. <code class="command">lavaps</code> displays running processes as the wax bubbles in a lava-lamp. <span class="emphasis"><em>bubblemon</em></span> is a desktop panel applet representing the amount of used memory and the processor usage as an aquarium with bubbles. <code class="command">bubblefishymon</code> is rather similar, but it also adds fish representing network traffic (and even a duck).
				</div></div><a id="idp12327840" class="indexterm"></a><a id="idp12328384" class="indexterm"></a><a id="idp12328944" class="indexterm"></a><a id="idp12329488" class="indexterm"></a></div><div class="section"><div class="titlepage"><div><div><h4 class="title" id="section.surveillance-historique">14.3.2.2. History</h4></div></div></div><a id="idp12330824" class="indexterm"></a><div class="para"><p></p>
					Processor load, network traffic and free disk space are information that are constantly varying. Keeping a history of their evolution is often useful in determining exactly how the computer is used.
				</div><a id="idp12331728" class="indexterm"></a><a id="idp12332208" class="indexterm"></a><div class="para"><p></p>
					There are many dedicated tools for this task. Most can fetch data via SNMP (<span class="emphasis"><em>Simple Network Management Protocol</em></span>) in order to centralize this information. An added benefit is that this allows fetching data from network elements that may not be general-purpose computers, such as dedicated network routers or switches.
				</div><div class="para"><p></p>
					This book deals with Munin in some detail (see <a class="xref" href="sect.monitoring.html#section.munin">Section 12.4.1, “Setting Up Munin”</a>) as part of <a class="xref" href="advanced-administration.html">Chapter 12: “<em>Advanced Administration</em>”</a>. Debian also provides a similar tool, <span class="pkg pkg">cacti</span>. Its deployment is slightly more complex, since it is based solely on SNMP. Despite having a web interface, grasping the concepts involved in configuration still requires some effort. Reading the HTML documentation (<code class="filename">/usr/share/doc/cacti/html/index.html</code>) should be considered a prerequisite.
				</div><div class="sidebar fil"><div class="titlepage"><div><div><h6><span class="emphasis"><em>ALTERNATIVE</em></span> <code class="command">mrtg</code></h6></div></div></div><a id="idp12336112" class="indexterm"></a><div class="para"><p></p>
					<code class="command">mrtg</code> (in the similarly-named package) is an older tool. Despite some rough edges, it can aggregate historical data and display them as graphs. It includes a number of scripts dedicated to collecting the most commonly monitored data such as processor load, network traffic, web page hits, and so on.
				</div><div class="para"><p></p>
					The <span class="pkg pkg">mrtg-contrib</span> and <span class="pkg pkg">mrtgutils</span> packages contain example scripts that can be used directly.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="idp12338744">14.3.3. Detecting Changes</h3></div></div></div><div class="para"><p></p>
				Once the system is installed and configured, and barring security upgrades, there's usually no reason for most of the files and directories to evolve, data excepted. It is therefore interesting to make sure that files actually do not change: any unexpected change would therefore be worth investigating. This section presents a few tools able to monitor files and to warn the administrator when an unexpected change occurs (or simply to list such changes).
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title" id="section.debsums">14.3.3.1. Auditing Packages: <code class="command">debsums</code> and its Limits</h4></div></div></div><a id="idp12340568" class="indexterm"></a><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>GOING FURTHER</em></span> Protecting against upstream changes</h6></div></div></div><div class="para"><p></p>
					<code class="command">debsums</code> is useful in detecting changes to files coming from a Debian package, but it will be useless if the package itself is compromised, for instance if the Debian mirror is compromised. Protecting against this class of attacks involves using APT's digital signature verification system (see <a class="xref" href="sect.package-authentication.html">Section 6.5, “Checking Package Authenticity”</a>), and taking care to only install packages from a certified origin.
				</div></div><div class="para"><p></p>
					<code class="command">debsums</code> is an interesting tool since it allows finding what installed files have been modified (potentially by an attacker), but this should be taken with a grain of salt. First, because not all Debian packages provide the fingerprints required by this program (they can be found in <code class="filename">/var/lib/dpkg/info/<em class="replaceable"><code>package</code></em>.md5sums</code> when they exist). 
					<a id="idp12343976" class="indexterm"></a>
					 <a id="idp12344456" class="indexterm"></a>
					 <a id="idp12344936" class="indexterm"></a>
					 <a id="idp12345416" class="indexterm"></a>
					 As a reminder: a fingerprint is a value, often a number (even though in hexadecimal notation), that contains a kind of signature for the contents of a file. This signature is calculated with an algorithm (MD5 or SHA1 being well-known examples) that more or less guarantee that even the tiniest change in the file contents implies a change in the fingerprint; this is known as the “avalanche effect”. This allows a simple numerical fingerprint to serve as a litmus test to check whether the contents of a file have been altered. These algorithms are not reversible; in other words, for most of them, knowing a fingerprint doesn't allow finding the corresponding contents. Recent mathematical advances seem to weaken the absoluteness of these principles, but their use is not called into question so far, since creating different contents yielding the same fingerprint still seems to be quite a difficult task.
				</div><div class="para"><p></p>
					In addition, the <code class="filename">md5sums</code> files are stored on the hard disk; a thorough attacker will therefore update these files so they contain the new control sums for the subverted files.
				</div><div class="para"><p></p>
					The first drawback can be avoided by asking <code class="command">debsums</code> to base its checks on a <code class="filename">.deb</code> package instead of relying on the <code class="filename">md5sums</code> file. But that requires dowloading the matching <code class="filename">.deb</code> files first:
				</div><pre class="screen">
<code class="computeroutput"># </code><strong class="userinput"><code>apt-get --reinstall -d install `debsums -l`</code></strong>
<code class="computeroutput">[ ... ]
# </code><strong class="userinput"><code>debsums -p /var/cache/apt/archives -g</code></strong>
</pre><div class="para"><p></p>
					It is also worth noting that, in its default configuration, <code class="command">debsums</code> automatically generates the missing <code class="filename">md5sums</code> files whenever a package is installed using APT.
				</div><div class="para"><p></p>
					The other problem can be avoided in a similar fashion: the check must simply be based on a pristine <code class="filename">.deb</code> file. Since this implies having all the <code class="filename">.deb</code> files for all the installed packages, and being sure of their integrity, the simplest way is to grab them from a Debian mirror. This operation can be slow and tedious, and should therefore not be considered a proactive technique to be used on a regular basis.
				</div><pre class="screen">
<code class="computeroutput"># </code><strong class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code class="computeroutput">[ ... ]
# </code><strong class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong>
</pre><div class="para"><p></p>
					Note that this example uses the <code class="command">grep-status</code> command from the <span class="pkg pkg">grep-dctrl</span> package, which is not installed by default.
				</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title" id="idp12353864">14.3.3.2. Monitoring Files: AIDE</h4></div></div></div><a id="idp12354248" class="indexterm"></a><div class="para"><p></p>
					The AIDE tool (<span class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) allows checking file integrity, and detecting any change against a previously recorded image of the valid system. This image is stored as a database (<code class="filename">/var/lib/aide/aide.db</code>) containing the relevant information on all files of the system (fingerprints, permissions, timestamps and so on). This database is first initialized with <code class="command">aideinit</code>; it is then used daily (by the <code class="filename">/etc/cron.daily/aide</code> script) to check that nothing relevant changed. When changes are detected, AIDE records them in log files (<code class="filename">/var/log/aide/*.log</code>) and sends its findings to the administrator by email.
				</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>IN PRACTICE</em></span> Protecting the database</h6></div></div></div><div class="para"><p></p>
					Since AIDE uses a local database to compare the states of the files, the validity of its results is directly linked to the validity of the database. If an attacker gets root permissions on a compromised system, they will be able to replace the database and cover their tracks. A possible workaround would be to store the reference data on read-only storage media.
				</div></div><div class="para"><p></p>
					Many options in <code class="filename">/etc/default/aide</code> can be used to tweak the behaviour of the <span class="pkg pkg">aide</span> package. The AIDE configuration proper is stored in <code class="filename">/etc/aide/aide.conf</code> and <code class="filename">/etc/aide/aide.conf.d/</code> (actually, these files are only used by <code class="command">update-aide.conf</code> to generate <code class="filename">/var/lib/aide/aide.conf.autogenerated</code>). Configuration indicates which properties of which files need to be checked. For instance, the contents of log files changes routinely, and such changes can be ignored as long as the permissions of these files stay the same, but both contents and permissions of executable programs must be constant. Although not very complex, the configuration syntax is not fully intuitive, and reading the <span class="citerefentry"><span class="refentrytitle">aide.conf</span>(5)</span> manual page is therefore recommended.
				</div><div class="para"><p></p>
					A new version of the database is generated daily in <code class="filename">/var/lib/aide/aide.db.new</code>; if all recorded changes were legitimate, it can be used to replace the reference database.
				</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>ALTERNATIVE</em></span> Tripwire and Samhain</h6></div></div></div><div class="para"><p></p>
					Tripwire is very similar to AIDE; even the configuration file syntax is almost the same. The main addition provided by <span class="pkg pkg">tripwire</span> is a mechanism to sign the configuration file, so that an attacker cannot make it point at a different version of the reference database.
				</div><div class="para"><p></p>
					Samhain also offers similar features, as well as some functions to help detecting rootkits (see the QUICK LOOK sidebar). It can also be deployed globally on a network, and record its traces on a central server (with a signature).
				</div></div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>QUICK LOOK</em></span> The <span class="pkg pkg">checksecurity</span> and <span class="pkg pkg">chkrootkit</span>/<span class="pkg pkg">rkhunter</span> packages</h6></div></div></div><a id="idp12365272" class="indexterm"></a><div class="para"><p></p>
					The first of these packages contains several small scripts performing basic checks on the system (empty passwords, new setuid files, and so on) and warning the administrator if required. Despite its explicit name, an administrator should not rely solely on it to make sure a Linux system is secure.
				</div><div class="para"><p></p>
					The <span class="pkg pkg">chkrootkit</span> and <span class="pkg pkg">rkhunter</span> packages allow looking for <span class="emphasis"><em>rootkits</em></span> potentially installed on the system. As a reminder, these are pieces of sofware designed to hide the compromise of a system while discreetly keeping control of the machine. The tests are not 100% reliable, but they can usually draw the administrator's attention to potential problems.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.detection-intrusion">14.3.4. Detecting Intrusion (IDS/NIDS)</h3></div></div></div><a id="idp12368880" class="indexterm"></a><a id="idp12369344" class="indexterm"></a><a id="idp12369808" class="indexterm"></a><a id="idp12370288" class="indexterm"></a><a id="idp12370752" class="indexterm"></a><a id="idp12371232" class="indexterm"></a><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>BACK TO BASICS</em></span> Denial of service</h6></div></div></div><a id="idp12372480" class="indexterm"></a><div class="para"><p></p>
				A “denial of service” attack has only one goal: to make a service unavailable. Whether such an attack involves overloading the server with queries or exploiting a bug, the end result is the same: the service is no longer operational. Regular users are unhappy, and the entity hosting the targeted network service suffers a loss in reputation (and possibly in revenue, for instance if the service was an e-commerce site).
			</div><div class="para"><p></p>
				Such an attack is sometimes “distributed”; this usually involves overloading the server with large numbers of queries coming from many different sources so that the server becomes unable to answer the legitimate queries. These types of attacks have gained well-known acronyms: <acronym class="acronym">DoS</acronym> and <acronym class="acronym">DDoS</acronym> (depending on whether the denial of service attack is distributed or not).
			</div></div><div class="para"><p></p>
				<code class="command">snort</code> (in the Debian package of the same name) is a NIDS — a <span class="emphasis"><em>Network Intrusion Detection System</em></span>. Its function is to listen to the network and try to detect infiltration attempts and/or hostile acts (including denial of service attacks). All these events are logged, and a daily email is sent to the administrator with a summary of the past 24 hours.
			</div><a id="idp12375800" class="indexterm"></a><div class="para"><p></p>
				Its configuration requires describing the range of addresses that the local network covers. In practice, this means the set of all potential attack targets. Other important parameters can be configured with <code class="command">dpkg-reconfigure snort</code>, including the network interface to monitor. This will often be <code class="literal">eth0</code> for an Ethernet connection, but other possibilities exist such as <code class="literal">ppp0</code> for an ADSL or PSTN (<span class="emphasis"><em>Public Switched Telephone Network</em></span>, or good old dialup modem), or even <code class="literal">wlan0</code> for some wireless network cards.
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>Going Further</em></span> Integration with <code class="command">prelude</code></h6></div></div></div><div class="para"><p></p>
				Prelude brings centralized monitoring of security information. Its modular architecture includes a server (the <span class="emphasis"><em>manager</em></span> in <span class="pkg pkg">prelude-manager</span>) which gathers alerts generated by <span class="emphasis"><em>sensors</em></span> of various types.
			</div><div class="para"><p></p>
				Snort can be configured as such a sensor. Other possibilities include <span class="emphasis"><em>prelude-lml</em></span> (<span class="emphasis"><em>Log Monitor Lackey</em></span>) which monitors log files (in a manner similar to <code class="command">logcheck</code>, described in <a class="xref" href="sect.supervision.html#section.logcheck">Section 14.3.1, “Monitoring Logs with <code class="command">logcheck</code>”</a>).
			</div><a id="idp12381416" class="indexterm"></a></div><div class="para"><p></p>
				The <code class="command">snort</code> configuration file (<code class="filename">/etc/snort/snort.conf</code>) is very long, and the abundant comments describe each directive with much detail. Getting the most out of it requires reading it in full and adapting it to the local situation. For instance, indicating which machine hosts which service can limit the number of incidents <code class="command">snort</code> will report, since a denial of service attack on a desktop machine is far from being as critical as one on a DNS server. Another interesting directive allows storing the mappings between IP addresses and MAC addresses (these uniquely identify a network card), so as to allow detecting <span class="emphasis"><em>ARP spoofing</em></span> attacks by which a compromised machine attempts to masquerade as another such as a sensitive server.
			</div><div class="sidebar fil"><div class="titlepage"><div><div><h6><span class="emphasis"><em>CAUTION</em></span> Range of action</h6></div></div></div><div class="para"><p></p>
				The effectiveness of <code class="command">snort</code> is limited by the traffic seen on the monitored network interface. It will obviously not be able to detect anything if it cannot observe the real traffic. When plugged into a network switch, it will therefore only monitor attacks targeting the machine it runs on, which is probably not the intention. The machine hosting <code class="command">snort</code> should therefore be plugged into the “mirror” port of the switch, which is usually dedicated to chaining switches and therefore gets all the traffic.
			</div><div class="para"><p></p>
				On a small network based around a network hub, there is no such problem, since all machines get all the traffic.
			</div></div></div></div><div id="site_footer"></div><script type="text/javascript">
		$("#site_footer").load("../../../../../footer.html");
	</script><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.firewall-packet-filtering.html"><strong>Prev</strong>14.2. Firewall or Packet Filtering</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect.selinux.html"><strong>Next</strong>14.4. Introduction to SELinux</a></li></ul></body></html>
