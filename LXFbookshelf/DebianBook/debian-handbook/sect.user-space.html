<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>B.5. The User Space</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 3.0" /><meta name="package" content="Debian-debian-handbook-6.0-en-US-1.0-1" /><meta name="keywords" content="BIOS, Kernel, Unix, Process, Hierarchy, Basic Commands" /><link rel="home" href="index.html" title="The Debian Administrator's Handbook" /><link rel="up" href="short-remedial-course.html" title="Appendix B. Short Remedial Course" /><link rel="prev" href="sect.kernel-role-and-tasks.html" title="B.4. Some Tasks Handled by the Kernel" /></head><body><p class="hidden" id="title"><a class="left" href="http://www.debian.org"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://debian-handbook.info"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.kernel-role-and-tasks.html"><strong>Prev</strong></a></li><li class="home">The Debian Administrator's Handbook</li><li class="next"></li></ul><div class="section"><div class="titlepage"><div><div><h2 class="title" id="sect.user-space">B.5. The User Space</h2></div></div></div><a id="idp14471584" class="indexterm"></a><a id="idp14472064" class="indexterm"></a><div class="para"><p></p>
			“User-space” refers to the runtime environment of normal (as opposed to kernel) processes. This does not necessarily mean these processes are actually started by users because a standard system routinely has several “daemon” processes running before the user even opens a session. Daemon processes are user-space processes.
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.rappels-processus">B.5.1. Process</h3></div></div></div><a id="idp14473632" class="indexterm"></a><div class="para"><p></p>
				When the kernel gets past its initialization phase, it starts the very first process, <code class="command">init</code>. Process #1 alone is very rarely useful by itself, and Unix-like systems run with a whole lifecycle of processes.
			</div><a id="idp14474864" class="indexterm"></a><div class="para"><p></p>
				First of all, a process can clone itself (this is known as a <span class="emphasis"><em>fork</em></span>). The kernel allocates a new, but identical, process memory space, and another process to use it. At this point in time, the only difference between these two processes is their <span class="emphasis"><em>pid</em></span>. The new process is customarily called a child process, and the process whose <span class="emphasis"><em>pid</em></span> doesn't change, is called the parent process.
			</div><div class="para"><p></p>
				Sometimes, the child process continues to lead its own life independently from its parent, with its own data copied from the the parent process. In many cases, though, this child process executes another program. With a few exceptions, its memory is simply replaced by that of the new program, and execution of this new program begins. One of the very first actions of process number 1 thus is to duplicate itself (which means there are, for a tiny amount of time, two running copies of the same <code class="command">init</code> process), but the child process is then replaced by the first system initialization script, usually <code class="filename">/etc/init.d/rcS</code>. This script, in turn, clones itself and runs several other programs. At some point, one process among <code class="command">init</code>'s offspring starts a graphical interface for users to log in to (the actual sequence of events is described in more details in <a class="xref" href="unix-services.html#sect.system-boot">Section 9.1, “System Boot”</a>).
			</div><div class="para"><p></p>
				When a process finishes the task for which it was started, it terminates. The kernel then recovers the memory assigned to this process, and stops giving it slices of running time. The parent process is told about its child process being terminated, which allows a process to wait for the completion of a task it delegated to a child process. This behaviour is plainly visible in command-line interpreters (known as <span class="emphasis"><em>shells</em></span>). When a command is typed into a shell, the prompt only comes back when the execution of the command is over. Most shells allow for running the command in the background, it is a simple matter of adding an <strong class="userinput"><code>&amp;</code></strong> to the end of the command. The prompt is displayed again right away, which can lead to problems if the command needs to display data of its own.
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.daemons">B.5.2. Daemons</h3></div></div></div><a id="idp14480864" class="indexterm"></a><a id="idp14481344" class="indexterm"></a><div class="para"><p></p>
				A “daemon” is a process started automatically by the boot sequence. It keeps running (in the background) to perform maintenance tasks or provide services to other processes. This “background task” is actually arbitrary, and does not match anything particular from the system's point of view. They are simply processes, quite similar to other processes, which run in turn when their time slice comes. The distinction is only in the human language: a process that runs with no interaction with a user (in particular, without any graphical interface) is said to be running “in the background” or “as a daemon”.
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>VOCABULARY</em></span> Daemon, demon, a derogatory term?</h6></div></div></div><div class="para"><p></p>
				Although <span class="emphasis"><em>daemon</em></span> term shares its Greek etymology with <span class="emphasis"><em>demon</em></span>, the former does not imply diabolical evil, instead, it should be understood as a kind-of helper spirit. This distinction is subtle enough in English, but it's even worse in other languages where the same word is used for both meanings.
			</div></div><div class="para"><p></p>
				Several such daemons are described in detail in <a class="xref" href="unix-services.html">Chapter 9, <em>Unix Services</em></a>.
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.ipc">B.5.3. Inter-Process Communications</h3></div></div></div><a id="idp14485464" class="indexterm"></a><a id="idp14485944" class="indexterm"></a><div class="para"><p></p>
				An isolated process, whether a daemon or an interactive application, is rarely useful on its own, which is why there are several methods allowing separate processes to communicate together, either to exchange data or to control one another. The generic term referring to this is <span class="emphasis"><em>inter-process communication</em></span>, or IPC for short.
			</div><div class="para"><p></p>
				The simplest IPC system is to use files. The process that wishes to send data writes it into a file (with a name known in advance), while the recipient only has to open the file and read its contents.
			</div><a id="idp14487576" class="indexterm"></a><a id="idp14488136" class="indexterm"></a><div class="para"><p></p>
				In the case where one does not wish to store data on disk, one can use a <span class="emphasis"><em>pipe</em></span>, which is simply an object with two ends; bytes written in one end, are readable at the other. If the ends are controlled by separate processes, this leads to a simple and convenient inter-process communication channel. Pipes can be classified into two categories: named pipes, and anonymous pipes. A named pipe is represented by an entry on the filesystem (although the transmitted data is not stored there), so both processes can open it independently if the location of the named pipe is known beforehand. In cases where the communicating processes are related (for instance, a parent and its child process), the parent process can also create an anonymous pipe before forking, and the child inherits it. Both processes will then be able to exchange data through the pipe without needing the filesystem.
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>IN PRACTICE</em></span> A concrete example</h6></div></div></div><div class="para"><p></p>
				Let's describe in some detail what happens when a complex command (a <span class="emphasis"><em>pipeline</em></span>) is run from a shell. We assume we have a <code class="command">bash</code> process (the standard user shell on Debian), with <span class="emphasis"><em>pid</em></span> 4374; into this shell, we type the command: <code class="command">ls | sort</code> .
			</div><div class="para"><p></p>
				The shell first interprets the command typed in. In our case, it understands there are two programs (<code class="command">ls</code> and <code class="command">sort</code>), with a data stream flowing from one to the other (denoted by the <strong class="userinput"><code>|</code></strong> character, known as <span class="emphasis"><em>pipe</em></span>). <code class="command">bash</code> first creates an unnamed pipe (which initially exists only within the <code class="command">bash</code> process itself).
			</div><div class="para"><p></p>
				Then the shell clones itself; this leads to a new <code class="command">bash</code> process, with <span class="emphasis"><em>pid</em></span> #4521 (<span class="emphasis"><em>pids</em></span> are abstract numbers, and generally have no particular meaning). Process #4521 inherits the pipe, which means it is able to write in its “input” side; <code class="command">bash</code> redirects its standard output stream to this pipe's input. Then it executes (and replaces itself with) the <code class="command">ls</code> program, which lists the contents of the current directory. Since <code class="command">ls</code> writes on its standard output, and this output has previously been redirected, the results are effectively sent into the pipe.
			</div><div class="para"><p></p>
				A similar operation happens for the second command: <code class="command">bash</code> clones itself again, leading to a new <code class="command">bash</code> process with pid #4522. Since it is also a child process of #4374, it also inherits the pipe; <code class="command">bash</code> then connects its standard input to the pipe output, then executes (and replaces itself with) the <code class="command">sort</code> command, which sorts its input and displays the results.
			</div><div class="para"><p></p>
				All the pieces of the puzzle are now set up: <code class="command">ls</code> writes the list of files in the current directory into the pipe; <code class="command">sort</code> reads this list, sorts it alphabetically, and displays the results. Processes numbers #4521 and #4522 then terminate, and #4374 (which was waiting for them during the operation), resumes control and displays the prompt to allow the user to type in a new command.
			</div></div><div class="para"><p></p>
				Not all inter-process communications are used to move data around though. In many situations, the only information that needs to be transmitted are control messages such as “pause execution” or “resume execution”. Unix (and Linux) provides a mechanism known as <span class="emphasis"><em>signals</em></span>, through which a process can simply send a signal (chosen within a fixed list of a few tens of predefined signals) to another process. The only requirement is to know the <span class="emphasis"><em>pid</em></span> of the target.
			</div><div class="para"><p></p>
				For more complex communications, there are also mechanisms allowing a process to open access, or share, part of its allocated memory to other processes. Memory then shared between them, allows moving data across.
			</div><div class="para"><p></p>
				Finally, network connections can also help processes communicate; these processes can even be running on different computers, possibly thousands of kilometers apart.
			</div><div class="para"><p></p>
				It is quite standard for a typical Unix-like system to make use of all these mechanisms to various degrees.
			</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="section.bibliotheques">B.5.4. Libraries</h3></div></div></div><a id="idp14501520" class="indexterm"></a><div class="para"><p></p>
				Function libraries play a crucial role in a Unix-like operating system. They are not proper programs, since they cannot be executed on their own, but collections of code fragments that can be used by standard programs. Among the common libraries, the most noteworthy include:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para"><p></p>
						the standard C library (<span class="emphasis"><em>glibc</em></span>), which contains basic functions such as ones to open files or network connections, and others facilitating interactions with the kernel;
					</div></li><li class="listitem"><div class="para"><p></p>
						graphical toolkits, Gtk+ and Qt, allowing many programs to reuse the graphical objects they provide;
					</div></li><li class="listitem"><div class="para"><p></p>
						the <span class="emphasis"><em>libpng</em></span> library, that allows loading, interpreting and saving images in the PNG format.
					</div></li></ul></div><div class="para"><p></p>
				Thanks to those libraries, applications can reuse existing code. Their development is thus correspondingly simplified, in particular when many applications reuse the same functions. Since libraries are often developed by different persons, the global development of the system is closer to Unix's historical philosophy.
			</div><div class="sidebar"><div class="titlepage"><div><div><h6><span class="emphasis"><em>CULTURE</em></span> The Unix Way: one thing at a time</h6></div></div></div><div class="para"><p></p>
				One of the fundamental concepts that underlies the Unix family of operating systems is that each tool should only do one thing, and do it well; applications can then reuse these tools to build more advanced logic on top. This Way can be seen in many incarnations. Shell scripts may be the best example: they assemple complex sequences of very simple tools (such as <code class="command">grep</code>, <code class="command">wc</code>, <code class="command">sort</code>, <code class="command">uniq</code> and so on). Another implementation of this philosophy can be seen in code libraries: the <span class="emphasis"><em>libpng</em></span> library allows reading and writing PNG images, with different options and in different ways, but it does only that; no question of including functions that display or edit images.
			</div></div><div class="para"><p></p>
				Moreover, these libraries are often referred to as “shared libraries”, since the kernel is able to only load them into memory once, even if several processes use the same library at the same time. This allows saving memory, when compared with the opposite (hypothetical) situation where the code for a library would be loaded as many times as there are processes using it.
			</div></div></div><div id="site_footer"></div><script type="text/javascript">
		$("#site_footer").load("../../../../../footer.html");
	</script><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.kernel-role-and-tasks.html"><strong>Prev</strong>B.4. Some Tasks Handled by the Kernel</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li></ul></body></html>
